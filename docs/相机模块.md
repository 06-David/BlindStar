# BlindStar 相机模块文档

## 📖 模块概述

BlindStar相机模块负责视频流的捕获、处理和管理，是整个视觉系统的数据输入源。支持多种视频源，包括USB摄像头、IP摄像头和视频文件，提供稳定可靠的图像数据流。

## 🏗️ 架构设计

### 核心组件
- **相机管理器** (`core/camera.py`): 相机设备管理和视频流控制
- **视频处理器** (`core/video_processor.py`): 视频文件处理和编码
- **帧缓冲管理**: 智能帧缓冲和内存管理
- **多源支持**: 支持多种视频输入源

### 技术栈
- **OpenCV**: 视频捕获和处理核心库
- **Threading**: 多线程异步视频处理
- **Queue**: 线程安全的帧队列管理
- **NumPy**: 图像数据处理和操作

## 📷 相机管理系统

### Camera类
核心相机管理组件：

```python
class Camera:
    def __init__(self, source=0, resolution=(640, 480), fps=30):
        self.source = source              # 视频源
        self.resolution = resolution      # 分辨率
        self.target_fps = fps            # 目标帧率
        self.cap = None                  # OpenCV VideoCapture对象
        self.is_opened = False           # 相机状态
        self.frame_count = 0             # 帧计数器
        self.last_frame_time = 0         # 上一帧时间戳
```

### 支持的视频源类型

#### 1. USB摄像头
```python
# 使用设备索引
camera = Camera(source=0)  # 默认摄像头
camera = Camera(source=1)  # 第二个摄像头

# 设置分辨率和帧率
camera = Camera(source=0, resolution=(1280, 720), fps=30)
```

#### 2. IP摄像头
```python
# RTSP流
camera = Camera(source="rtsp://192.168.1.100:554/stream")

# HTTP流
camera = Camera(source="http://192.168.1.100:8080/video")
```

#### 3. 视频文件
```python
# 本地视频文件
camera = Camera(source="path/to/video.mp4")

# 支持的格式: MP4, AVI, MOV, MKV等
```

### 相机控制功能

#### 1. 基本控制
```python
def open(self):
    """打开相机"""
    self.cap = cv2.VideoCapture(self.source)
    if self.cap.isOpened():
        self.configure_camera()
        self.is_opened = True
        return True
    return False

def close(self):
    """关闭相机"""
    if self.cap and self.cap.isOpened():
        self.cap.release()
        self.is_opened = False

def read_frame(self):
    """读取单帧"""
    if not self.is_opened:
        return None, None
        
    ret, frame = self.cap.read()
    if ret:
        self.frame_count += 1
        self.last_frame_time = time.time()
        return True, frame
    return False, None
```

#### 2. 参数配置
```python
def configure_camera(self):
    """配置相机参数"""
    if self.cap and self.cap.isOpened():
        # 设置分辨率
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.resolution[0])
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.resolution[1])
        
        # 设置帧率
        self.cap.set(cv2.CAP_PROP_FPS, self.target_fps)
        
        # 设置缓冲区大小
        self.cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
        
        # 自动曝光和白平衡
        self.cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0.75)
        self.cap.set(cv2.CAP_PROP_AUTO_WB, 1)
```

#### 3. 状态监控
```python
def get_camera_info(self):
    """获取相机信息"""
    if not self.is_opened:
        return None
        
    info = {
        'width': int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH)),
        'height': int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT)),
        'fps': self.cap.get(cv2.CAP_PROP_FPS),
        'frame_count': self.frame_count,
        'backend': self.cap.getBackendName(),
        'is_color': bool(self.cap.get(cv2.CAP_PROP_MODE))
    }
    return info
```

## 🎥 视频处理器

### VideoProcessor类
视频文件处理和编码管理：

```python
class VideoProcessor:
    def __init__(self):
        self.input_path = None
        self.output_path = None
        self.writer = None
        self.codec = 'mp4v'
        self.quality = 0.8
        
    def setup_writer(self, output_path, fps, frame_size):
        """设置视频写入器"""
        fourcc = cv2.VideoWriter_fourcc(*self.codec)
        self.writer = cv2.VideoWriter(
            output_path, fourcc, fps, frame_size
        )
        return self.writer.isOpened()
```

### 视频处理功能

#### 1. 视频录制
```python
def start_recording(self, output_path, fps=30, frame_size=(640, 480)):
    """开始录制视频"""
    self.output_path = output_path
    return self.setup_writer(output_path, fps, frame_size)

def write_frame(self, frame):
    """写入帧到视频文件"""
    if self.writer and self.writer.isOpened():
        self.writer.write(frame)
        return True
    return False

def stop_recording(self):
    """停止录制"""
    if self.writer:
        self.writer.release()
        self.writer = None
```

#### 2. 视频格式转换
```python
def convert_video(self, input_path, output_path, 
                 target_fps=None, target_size=None):
    """转换视频格式"""
    cap = cv2.VideoCapture(input_path)
    
    # 获取原始参数
    original_fps = cap.get(cv2.CAP_PROP_FPS)
    original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    
    # 设置目标参数
    fps = target_fps or original_fps
    width, height = target_size or (original_width, original_height)
    
    # 设置写入器
    self.setup_writer(output_path, fps, (width, height))
    
    # 逐帧转换
    while True:
        ret, frame = cap.read()
        if not ret:
            break
            
        if target_size:
            frame = cv2.resize(frame, target_size)
            
        self.write_frame(frame)
    
    cap.release()
    self.stop_recording()
```

## 🔄 帧缓冲管理

### FrameBuffer类
智能帧缓冲和内存管理：

```python
class FrameBuffer:
    def __init__(self, max_size=10):
        self.max_size = max_size
        self.buffer = queue.Queue(maxsize=max_size)
        self.dropped_frames = 0
        self.total_frames = 0
        
    def put_frame(self, frame, timestamp=None):
        """添加帧到缓冲区"""
        self.total_frames += 1
        
        if self.buffer.full():
            # 丢弃最旧的帧
            try:
                self.buffer.get_nowait()
                self.dropped_frames += 1
            except queue.Empty:
                pass
        
        frame_data = {
            'frame': frame,
            'timestamp': timestamp or time.time(),
            'frame_id': self.total_frames
        }
        
        try:
            self.buffer.put_nowait(frame_data)
            return True
        except queue.Full:
            self.dropped_frames += 1
            return False
    
    def get_frame(self, timeout=1.0):
        """从缓冲区获取帧"""
        try:
            return self.buffer.get(timeout=timeout)
        except queue.Empty:
            return None
```

### 自适应缓冲策略
```python
class AdaptiveFrameBuffer(FrameBuffer):
    def __init__(self, initial_size=5, max_size=20):
        super().__init__(max_size=initial_size)
        self.max_possible_size = max_size
        self.performance_monitor = PerformanceMonitor()
        
    def adjust_buffer_size(self):
        """根据性能动态调整缓冲区大小"""
        processing_time = self.performance_monitor.get_avg_processing_time()
        frame_rate = self.performance_monitor.get_frame_rate()
        
        if processing_time > 100:  # 100ms
            # 处理较慢，增加缓冲区
            new_size = min(self.max_size + 2, self.max_possible_size)
        elif processing_time < 33:  # 33ms (30fps)
            # 处理较快，减少缓冲区
            new_size = max(self.max_size - 1, 3)
        else:
            return
            
        self.resize_buffer(new_size)
```

## ⚙️ 配置参数

### 相机配置
```python
CAMERA_CONFIG = {
    'default_source': 0,                    # 默认视频源
    'default_resolution': (640, 480),       # 默认分辨率
    'default_fps': 30,                      # 默认帧率
    'buffer_size': 1,                       # OpenCV缓冲区大小
    'auto_exposure': True,                  # 自动曝光
    'auto_white_balance': True,             # 自动白平衡
    'reconnect_attempts': 5,                # 重连尝试次数
    'reconnect_delay': 2.0                  # 重连延迟(秒)
}
```

### 视频处理配置
```python
VIDEO_CONFIG = {
    'default_codec': 'mp4v',               # 默认编码器
    'quality': 0.8,                        # 视频质量
    'max_file_size': 1024 * 1024 * 1024,  # 最大文件大小(1GB)
    'segment_duration': 600,               # 分段时长(秒)
    'enable_hardware_encoding': True,      # 硬件编码
    'compression_level': 6                 # 压缩级别
}
```

### 帧缓冲配置
```python
BUFFER_CONFIG = {
    'default_buffer_size': 5,              # 默认缓冲区大小
    'max_buffer_size': 20,                 # 最大缓冲区大小
    'adaptive_buffering': True,            # 自适应缓冲
    'drop_frame_threshold': 0.1,           # 丢帧阈值
    'memory_limit': 512 * 1024 * 1024     # 内存限制(512MB)
}
```

## 🛠️ 使用方法

### 基本相机使用
```python
from core.camera import Camera

# 初始化相机
camera = Camera(source=0, resolution=(1280, 720), fps=30)

# 打开相机
if camera.open():
    print("相机打开成功")
    
    # 读取帧
    while True:
        ret, frame = camera.read_frame()
        if ret:
            # 处理帧
            cv2.imshow("Camera", frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        else:
            print("读取帧失败")
            break
    
    # 关闭相机
    camera.close()
else:
    print("无法打开相机")
```

### 视频录制
```python
from core.camera import Camera
from core.video_processor import VideoProcessor

camera = Camera(source=0)
processor = VideoProcessor()

if camera.open():
    # 开始录制
    processor.start_recording("output.mp4", fps=30, frame_size=(640, 480))
    
    # 录制循环
    for i in range(300):  # 录制10秒(30fps)
        ret, frame = camera.read_frame()
        if ret:
            processor.write_frame(frame)
    
    # 停止录制
    processor.stop_recording()
    camera.close()
```

### 多线程视频处理
```python
import threading
from core.camera import Camera
from core.frame_buffer import FrameBuffer

class ThreadedCamera:
    def __init__(self, source=0):
        self.camera = Camera(source)
        self.buffer = FrameBuffer(max_size=10)
        self.capture_thread = None
        self.is_running = False
        
    def start_capture(self):
        """启动捕获线程"""
        if self.camera.open():
            self.is_running = True
            self.capture_thread = threading.Thread(target=self._capture_loop)
            self.capture_thread.start()
            
    def _capture_loop(self):
        """捕获循环"""
        while self.is_running:
            ret, frame = self.camera.read_frame()
            if ret:
                self.buffer.put_frame(frame)
            else:
                time.sleep(0.01)
                
    def get_latest_frame(self):
        """获取最新帧"""
        return self.buffer.get_frame(timeout=0.1)
        
    def stop_capture(self):
        """停止捕获"""
        self.is_running = False
        if self.capture_thread:
            self.capture_thread.join()
        self.camera.close()
```

## 🔧 故障排除

### 常见问题

#### 1. 相机无法打开
```
原因: 设备被占用或驱动问题
解决:
- 检查设备是否被其他程序占用
- 更新相机驱动程序
- 尝试不同的设备索引
- 检查USB连接
```

#### 2. 帧率不稳定
```
原因: 处理能力不足或缓冲设置不当
解决:
- 降低分辨率或帧率
- 调整缓冲区大小
- 使用多线程处理
- 优化处理算法
```

#### 3. 视频录制失败
```
原因: 编码器不支持或磁盘空间不足
解决:
- 检查磁盘空间
- 尝试不同的编码器
- 调整视频质量设置
- 检查文件权限
```

### 调试命令
```bash
# 测试相机
python -m core.camera --test-camera 0

# 检查可用相机
python -m core.camera --list-cameras

# 录制测试视频
python -m core.camera --record --duration 10 --output test.mp4
```

## 📊 性能指标

### 相机性能
- **支持分辨率**: 320x240 - 1920x1080
- **支持帧率**: 1-60 FPS
- **启动时间**: < 2秒
- **内存占用**: < 100MB

### 视频处理性能
- **录制性能**: 实时录制无丢帧
- **格式转换**: 1080p视频 ~2x实时速度
- **编码效率**: H.264硬件编码支持
- **文件大小**: 1080p@30fps ~100MB/分钟

### 缓冲性能
- **缓冲延迟**: < 100ms
- **丢帧率**: < 1%（正常负载）
- **内存效率**: 自适应内存管理
- **并发支持**: 支持多路视频流

## 🔄 更新日志

### v1.3 (当前版本)
- ✅ 实现自适应帧缓冲管理
- ✅ 添加多线程视频处理支持
- ✅ 优化相机参数自动配置
- ✅ 支持硬件编码加速

### v1.2
- ✅ 添加IP摄像头支持
- ✅ 实现视频格式转换
- ✅ 优化内存管理

### v1.1
- ✅ 基础相机捕获功能
- ✅ 简单视频录制
- ✅ 基本参数配置

## 📚 相关文档
- [检测模块文档](./检测模块.md)
- [深度估计模块文档](./深度估计模块.md)
- [系统配置文档](./configuration.md)
- [性能优化文档](./performance.md)
